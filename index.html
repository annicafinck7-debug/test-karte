<script>
/* =========================
   SHEETS
   ========================= */
const CONFIG = {
  firmsCsvUrl: "https://docs.google.com/spreadsheets/d/1f1oD1TlYWPRbD12d05yIGkqmXVygVt3ZHLk9U0bKoTs/gviz/tq?tqx=out:csv&gid=0",
  customersCsvUrl: "https://docs.google.com/spreadsheets/d/1DaiLyZbhJkdSQ1PHbJQmguIrDnGrrhiAVgJC4PJO8vA/gviz/tq?tqx=out:csv&gid=0",
  deliveriesCsvUrl: "https://docs.google.com/spreadsheets/d/1fcvlM2BUDpoV-HDyPtgDf_1ZqWql6MdEMbisR0eqYYw/gviz/tq?tqx=out:csv&gid=0",
  geocodeDelayMs: 1100
};

/* =========================
   LocalStorage Keys
   ========================= */
const LS_GEO_CACHE_KEY = "salesMap_geoCache_v11";
const LS_PRICE_OVERRIDES_KEY = "salesMap_priceOverrides_v11";
const LS_PANEL_POS_KEY = "salesMap_panelPos_v11";
const LS_COLOR_SCHEME_KEY = "salesMap_colorScheme_v6";
const LS_THEME_KEY = "salesMap_theme_v5";

/* ‚úÖ NEU */
const LS_ZONES_KEY = "salesMap_zones_v1";
const LS_NOTES_KEY = "salesMap_notes_v1";
const LS_PLACE_CACHE_KEY = "salesMap_placeCache_v1";

/* =========================
   State
   ========================= */
let map, customers=[], firms=[];
let customerMarkers=[], firmMarkers=[];
let selectedCustomer=null;
let routeLayer=null;

/* ‚úÖ AUFTR√ÑGE */
let deliveriesLoaded = false;
let deliveriesAgg = [];
let deliveriesByCustomer = new Map();

let geoCache = loadLS(LS_GEO_CACHE_KEY, {});
let priceOverrides = loadLS(LS_PRICE_OVERRIDES_KEY, {});
let notesStore = loadLS(LS_NOTES_KEY, {});            // { "F0": "text", "C3": "text" }
let placeCache = loadLS(LS_PLACE_CACHE_KEY, {});     // { "rostock": {lat,lon,ts} }

/* ‚úÖ Zonen */
let zonesLayer = L.featureGroup();
let drawControl = null;
let drawEnabled = false;

/* =========================
   Init
   ========================= */
init();

async function init(){
  applyThemeFromLS();

  map = L.map('map', { worldCopyJump:true }).setView([51.2, 10.4], 6);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);

  // Zonen Layer
  zonesLayer.addTo(map);
  initZones();

  setTimeout(()=>map.invalidateSize(), 80);

  initPanelDrag();
  initUI();

  map.on("click", ()=>{
    clearRoute();
    hideDetail();
  });

  setLoadStatus("Lade Tabellen ‚Ä¶");
  await Promise.all([loadCustomers(), loadFirms(), loadDeliveries()]);
  applyCacheCoordsOnly();
  renderMarkers();
  updateCustomerKpi(null);
  updateLoadStatusCounts();
  updateMiniKpis({good:0, mid:0, bad:0});
}

/* =========================
   ZONEN (Leaflet Draw)
   ========================= */
function initZones(){
  // Restore from LS
  const stored = loadLS(LS_ZONES_KEY, null);
  if(stored && stored.type === "FeatureCollection"){
    try{
      const gj = L.geoJSON(stored, {
        style: { weight:2, fillOpacity:0.10 },
        onEachFeature: (feature, layer)=>{
          const name = feature?.properties?.name || "Zone";
          layer.bindTooltip(`<b>${esc(name)}</b>`, {sticky:true});
        }
      });
      gj.eachLayer(l=>zonesLayer.addLayer(l));
    }catch(e){}
  }

  // Draw control (hidden until toggle)
  drawControl = new L.Control.Draw({
    position: "topleft",
    draw: {
      polyline: false,
      circle: false,
      circlemarker: false,
      marker: false,
      polygon: { allowIntersection:false, showArea:true },
      rectangle: { showArea:true }
    },
    edit: {
      featureGroup: zonesLayer,
      remove: true
    }
  });

  // Events
  map.on(L.Draw.Event.CREATED, (e)=>{
    const layer = e.layer;
    const defaultName = "Zone " + (zonesLayer.getLayers().length + 1);
    const name = prompt("Zonen-Name:", defaultName) || defaultName;
    layer.feature = layer.feature || { type:"Feature", properties:{} };
    layer.feature.properties = layer.feature.properties || {};
    layer.feature.properties.name = name;

    layer.bindTooltip(`<b>${esc(name)}</b>`, {sticky:true});
    zonesLayer.addLayer(layer);
    saveZonesToLS();
    // optional: sofort neu rendern (Zone-Label in Tooltips)
    renderMarkers();
  });

  map.on(L.Draw.Event.EDITED, ()=>{
    saveZonesToLS();
    renderMarkers();
  });

  map.on(L.Draw.Event.DELETED, ()=>{
    saveZonesToLS();
    renderMarkers();
  });
}

function toggleZones(){
  drawEnabled = !drawEnabled;
  if(drawEnabled){
    map.addControl(drawControl);
  }else{
    try{ map.removeControl(drawControl); }catch(e){}
  }
}

function saveZonesToLS(){
  try{
    const geo = zonesLayer.toGeoJSON();
    saveLS(LS_ZONES_KEY, geo);
  }catch(e){}
}

function getZoneNameForLatLng(lat, lon){
  // returns first matching zone name or ""
  const fc = zonesLayer.toGeoJSON();
  if(!fc || !Array.isArray(fc.features)) return "";
  for(const f of fc.features){
    const name = f?.properties?.name || "Zone";
    if(pointInGeoJSONPolygon(lat, lon, f)) return name;
  }
  return "";
}

/* Ray casting: supports Polygon / MultiPolygon */
function pointInGeoJSONPolygon(lat, lon, feature){
  const geom = feature?.geometry;
  if(!geom) return false;

  if(geom.type === "Polygon"){
    return pointInPolygonRings(lat, lon, geom.coordinates);
  }
  if(geom.type === "MultiPolygon"){
    for(const poly of geom.coordinates){
      if(pointInPolygonRings(lat, lon, poly)) return true;
    }
  }
  return false;
}

function pointInPolygonRings(lat, lon, rings){
  // rings: [outerRing, hole1, hole2...], each ring: [ [lng,lat], ... ]
  if(!rings || !rings.length) return false;
  const outer = rings[0];
  if(!pointInRing(lat, lon, outer)) return false;
  // holes: if inside hole => false
  for(let i=1;i<rings.length;i++){
    if(pointInRing(lat, lon, rings[i])) return false;
  }
  return true;
}

function pointInRing(lat, lon, ring){
  let inside = false;
  for(let i=0, j=ring.length-1; i<ring.length; j=i++){
    const xi = ring[i][0], yi = ring[i][1];
    const xj = ring[j][0], yj = ring[j][1];
    const intersect =
      ((yi > lat) !== (yj > lat)) &&
      (lon < (xj - xi) * (lat - yi) / ((yj - yi) || 1e-12) + xi);
    if(intersect) inside = !inside;
  }
  return inside;
}

/* =========================
   CSV (robust: fallback auf ;)
   ========================= */
function parseCsv(url){
  return new Promise((resolve, reject)=>{
    Papa.parse(url, {
      download:true,
      header:true,
      skipEmptyLines:true,
      delimiter: "", // auto
      transformHeader: (h) => String(h||"").trim().toLowerCase(),
      complete: (res)=>{
        const first = res?.data?.[0];
        const keys = first ? Object.keys(first) : [];
        if(first && keys.length <= 1){
          Papa.parse(url, {
            download:true,
            header:true,
            skipEmptyLines:true,
            delimiter: ";",
            transformHeader: (h) => String(h||"").trim().toLowerCase(),
            complete: (res2)=>resolve(res2.data),
            error: reject
          });
          return;
        }
        resolve(res.data);
      },
      error: reject
    });
  });
}

/* =========================
   Kunden
   ========================= */
async function loadCustomers(){
  const rows = await parseCsv(CONFIG.customersCsvUrl);
  customers = rows.map((r, idx)=>{
    const name = str(r["name"] ?? r["kundenname"] ?? r["kunde"] ?? r["firma"] ?? r["unternehmen"]).trim();
    const ort  = str(r["ort"] ?? r["adresse"] ?? r["address"]).trim();

    return {
      id:"C"+idx,
      name: name || ort || "Kunde",
      address: ort,
      lat: NaN,
      lon: NaN,
      accepts: {
        lose: isYes(r["lose"]),
        sackware: isYes(r["sackware"]),
        industrieware: isYes(r["industrieware"]) || isYes(r["industrie"]) || isYes(r["sonstige"])
      },
      raw: r
    };
  }).filter(x=>x.address);
}

/* =========================
   Firmen
   ========================= */
async function loadFirms(){
  const rows = await parseCsv(CONFIG.firmsCsvUrl);

  firms = rows.map((r, idx)=>{
    const name = str(r["firma"] ?? r["name"]).trim();
    const ort  = str(r["ort"] ?? r["adresse"] ?? r["address"]).trim();

    const baseLose = toNum(r["preis"]);
    const baseSack = toNum(r["sackwarenp"]);
    const baseInd  = toNum(r["industriewal"] ?? r["industrieware"] ?? r["industriewar"] ?? r["industriewa"]);

    const stand = getStandFromRow(r);
    const sackInfo = str(r["sackware"]).trim();

    return {
      id:"F"+idx,
      name: name || "Firma",
      address: ort,
      base:{ lose: baseLose, sackware: baseSack, industrieware: baseInd },
      stand,
      sackInfo,
      lat: NaN,
      lon: NaN,
      raw: r
    };
  }).filter(x=>x.name && x.address);
}

/* =========================
   ‚úÖ AUFTR√ÑGE LADEN
   Spalten: kunde | firma | anzahl
   ========================= */
async function loadDeliveries(){
  try{
    const rows = await parseCsv(CONFIG.deliveriesCsvUrl);

    deliveriesAgg = rows.map(r=>{
      const kunde = str(r["kunde"]).trim();
      const firma = str(r["firma"]).trim();
      const anzahl = toInt(r["anzahl"]);
      return { kunde, firma, anzahl };
    }).filter(x => x.kunde && x.firma);

    deliveriesByCustomer = new Map();
    for(const d of deliveriesAgg){
      const k = normText(d.kunde);
      if(!deliveriesByCustomer.has(k)) deliveriesByCustomer.set(k, []);
      deliveriesByCustomer.get(k).push({ firma: d.firma, anzahl: d.anzahl });
    }

    for(const [k,list] of deliveriesByCustomer.entries()){
      list.sort((a,b)=> (b.anzahl||0) - (a.anzahl||0));
      deliveriesByCustomer.set(k, list);
    }

    deliveriesLoaded = true;
  }catch(e){
    deliveriesLoaded = false;
    deliveriesAgg = [];
    deliveriesByCustomer = new Map();
  }
}

/* =========================
   Geocoding + Cache
   ========================= */
function normAddr(a){ return str(a).trim().replace(/\s+/g,' '); }

function applyCacheCoordsOnly(){
  customers.forEach(c=>{
    const hit = geoCache[normAddr(c.address)];
    if(hit){ c.lat=hit.lat; c.lon=hit.lon; }
  });
  firms.forEach(f=>{
    const hit = geoCache[normAddr(f.address)];
    if(hit){ f.lat=hit.lat; f.lon=hit.lon; }
  });
}

async function geocodeAddress(address){
  const key = normAddr(address);
  if(!key) return null;

  if(geoCache[key] && isFinite(geoCache[key].lat) && isFinite(geoCache[key].lon)){
    return {lat: geoCache[key].lat, lon: geoCache[key].lon};
  }

  const url = "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" + encodeURIComponent(key);
  try{
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();
    if(data && data[0]){
      const lat = parseFloat(data[0].lat);
      const lon = parseFloat(data[0].lon);
      if(isFinite(lat) && isFinite(lon)){
        geoCache[key] = {lat, lon, ts: Date.now()};
        saveLS(LS_GEO_CACHE_KEY, geoCache);
        return {lat, lon};
      }
    }
  }catch(e){}
  return null;
}

/* ‚úÖ PLZ/ORT springen */
async function geocodePlace(q){
  const key = String(q||"").trim().toLowerCase();
  if(!key) return null;

  const cached = placeCache[key];
  if(cached && isFinite(cached.lat) && isFinite(cached.lon)){
    return {lat: cached.lat, lon: cached.lon};
  }

  const url = "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" + encodeURIComponent(q);
  try{
    const res = await fetch(url, { headers: { "Accept":"application/json" } });
    const data = await res.json();
    if(data && data[0]){
      const lat = parseFloat(data[0].lat);
      const lon = parseFloat(data[0].lon);
      if(isFinite(lat) && isFinite(lon)){
        placeCache[key] = {lat, lon, ts: Date.now()};
        saveLS(LS_PLACE_CACHE_KEY, placeCache);
        return {lat, lon};
      }
    }
  }catch(e){}
  return null;
}

function updateLoadStatusCounts(prefix=""){
  const totalC = customers.length;
  const totalF = firms.length;
  const doneC = customers.filter(c=>isFinite(c.lat)&&isFinite(c.lon)).length;
  const doneF = firms.filter(f=>isFinite(f.lat)&&isFinite(f.lon)).length;
  const delivTxt = deliveriesLoaded ? ` ¬∑ Auftr√§ge ‚úì` : ` ¬∑ Auftr√§ge ‚Äî`;
  setLoadStatus(`${prefix}${prefix? " ¬∑ ":""}Kunden ${doneC}/${totalC} ¬∑ Firmen ${doneF}/${totalF}${delivTxt}`);
}

async function geocodeAll(){
  const totalC = customers.length;
  const totalF = firms.length;

  let doneC = customers.filter(c=>isFinite(c.lat)&&isFinite(c.lon)).length;
  let doneF = firms.filter(f=>isFinite(f.lat)&&isFinite(f.lon)).length;

  setLoadStatus(`Kunden ${doneC}/${totalC} ¬∑ Firmen ${doneF}/${totalF}`);

  for(const c of customers){
    if(isFinite(c.lat) && isFinite(c.lon)) continue;
    const coords = await geocodeAddress(c.address);
    if(coords){
      c.lat = coords.lat; c.lon = coords.lon;
      doneC++;
      setLoadStatus(`Kunden ${doneC}/${totalC} ¬∑ Firmen ${doneF}/${totalF}`);
    }
    await sleep(CONFIG.geocodeDelayMs);
  }

  for(const f of firms){
    if(isFinite(f.lat) && isFinite(f.lon)) continue;
    const coords = await geocodeAddress(f.address);
    if(coords){
      f.lat = coords.lat; f.lon = coords.lon;
      doneF++;
      setLoadStatus(`Kunden ${doneC}/${totalC} ¬∑ Firmen ${doneF}/${totalF}`);
    }
    await sleep(CONFIG.geocodeDelayMs);
  }

  renderMarkers();
  if(selectedCustomer) updateCustomerKpi(selectedCustomer);
  setLoadStatus(`‚úÖ Fertig: Kunden ${doneC}/${totalC} ¬∑ Firmen ${doneF}/${totalF}`);
}

/* =========================
   Markers
   ========================= */
function customerTriangleIcon(){
  return L.divIcon({ html:`<div class="tri"></div>`, className:"", iconSize:[20,18], iconAnchor:[10,18] });
}

function firmColorByProduct(product){
  const scheme = document.getElementById("colorScheme")?.value || "standard";
  const palettes = {
    standard: { lose:"#2563eb", sackware:"#f59e0b", industrieware:"#16a34a" },
    pink:     { lose:"#e11d48", sackware:"#ec4899", industrieware:"#f9a8d4" },
    pastel:   { lose:"#93c5fd", sackware:"#fdba74", industrieware:"#86efac" }
  };
  return palettes[scheme]?.[product] || "#2563eb";
}
function firmFillColor(f, inputs){ return firmColorByProduct(inputs.product); }

function renderMarkers(){
  customerMarkers.forEach(m=>m.remove());
  firmMarkers.forEach(m=>m.remove());
  customerMarkers=[]; firmMarkers=[];

  customers.forEach(c=>{
    if(!isFinite(c.lat)||!isFinite(c.lon)) return;
    const zoneName = getZoneNameForLatLng(c.lat, c.lon);
    const note = (notesStore?.[c.id] || "").trim();
    const noteMark = note ? " üìù" : "";
    const zoneTxt = zoneName ? ` ¬∑ Zone: ${zoneName}` : "";

    const m = L.marker([c.lat,c.lon], {icon: customerTriangleIcon()}).addTo(map);

    const accTxt =
      `Lose: ${c.accepts?.lose ? "‚úì" : "‚Äî"} ¬∑ Sackware: ${c.accepts?.sackware ? "‚úì" : "‚Äî"} ¬∑ Industrie: ${c.accepts?.industrieware ? "‚úì" : "‚Äî"}`;

    m.bindTooltip(
      `<b>${esc(c.name)}${noteMark}</b><br>${esc(c.address)}<br><span class="small">${esc(accTxt)}${esc(zoneTxt)}</span>`,
      {direction:"top"}
    );

    m.on("click", ()=>{
      selectCustomer(c);
      const html = `
        <div class="rcard">
          <div class="h">${esc(c.name)}${note ? " üìù" : ""}</div>
          <div class="small">${esc(c.address)}${esc(zoneTxt)}</div>
          <div class="small" style="margin-top:6px;">Annahme: ${esc(accTxt)}</div>
          ${note ? `<div class="small" style="margin-top:8px;"><b>Notiz:</b><br>${esc(note).replace(/\n/g,"<br>")}</div>` : ""}
          <div class="note" style="margin-top:8px;">Rechtsklick auf den Kunden = Notiz bearbeiten</div>
        </div>
      `;
      L.popup({closeButton:true, autoClose:true, closeOnClick:true})
        .setLatLng([c.lat, c.lon])
        .setContent(html)
        .openOn(map);
    });

    // ‚úÖ NEU: Kunden-Notiz per Rechtsklick
    m.on("contextmenu", (e)=>openNotePopupForCustomer(c, e.latlng));

    customerMarkers.push(m);
  });

  const inputs = getInputs();
  const outline = document.body.classList.contains("dark") ? "rgba(229,231,235,.9)" : "rgba(15,23,42,.9)";

  firms.forEach(f=>{
    if(!isFinite(f.lat)||!isFinite(f.lon)) return;

    const fill = firmFillColor(f, inputs);
    const standTxt = f.stand ? ` (${f.stand})` : "";
    const sackInfoTxt = f.sackInfo ? ` ¬∑ Info: ${f.sackInfo}` : "";

    const zoneName = getZoneNameForLatLng(f.lat, f.lon);
    const zoneTxt = zoneName ? ` ¬∑ Zone: ${zoneName}` : "";

    const note = (notesStore?.[f.id] || "").trim();
    const noteMark = note ? " üìù" : "";

    const m = L.circleMarker([f.lat,f.lon], {
      radius:7,
      color: outline,
      weight: 2,
      fillColor: fill,
      fillOpacity:.9
    }).addTo(map);

    m.bindTooltip(
      `<b>${esc(f.name)}${noteMark}</b><br>${esc(f.address)}<br><span class="small">Stand${esc(standTxt)}${esc(sackInfoTxt)}${esc(zoneTxt)}</span>`,
      {direction:"top"}
    );

    m.on("mouseover", ()=>m.setStyle({radius:9, weight:3, fillOpacity:1}));
    m.on("mouseout", ()=>m.setStyle({radius:7, weight:2, fillOpacity:.9}));

    // ‚úÖ NEU: Rechtsklick = Preis + Notiz zusammen
    m.on("contextmenu", (e)=>openFirmPriceAndNotePopup(f, e.latlng));

    firmMarkers.push(m);
  });
}

/* =========================
   Notizen Popups
   ========================= */
function openNotePopupForCustomer(cust, latlng){
  const current = (notesStore?.[cust.id] || "").trim();

  const div = document.createElement("div");
  div.className = "rcard";
  div.innerHTML = `
    <div class="h">Notiz: ${esc(cust.name)}</div>
    <div class="small">${esc(cust.address)}</div>
    <div class="row2">
      <textarea id="noteTxt" placeholder="Notiz eingeben‚Ä¶">${esc(current)}</textarea>
    </div>
    <div class="note">Auto-Save: beim Rausklicken / Schlie√üen. (Esc schlie√üt)</div>
  `;

  const popup = L.popup({closeButton:true, autoClose:true, closeOnClick:true})
    .setLatLng(latlng)
    .setContent(div)
    .openOn(map);

  setTimeout(()=>{
    const ta = div.querySelector("#noteTxt");
    ta.focus();
    ta.addEventListener("keydown",(e)=>{
      if(e.key==="Escape") map.closePopup(popup);
    });
    const save = ()=>{
      const v = String(ta.value||"").trim();
      if(v) notesStore[cust.id] = v;
      else delete notesStore[cust.id];
      saveLS(LS_NOTES_KEY, notesStore);
      renderMarkers();
    };
    ta.addEventListener("blur", save);
    map.on("popupclose", save);
  }, 30);
}

function openFirmPriceAndNotePopup(firm, latlng){
  const product = document.getElementById("product").value;

  const currentOverride = priceOverrides?.[firm.id]?.[product];
  const currentPrice = isFinite(currentOverride) ? currentOverride : firm.base[product];

  const currentNote = (notesStore?.[firm.id] || "").trim();

  const div = document.createElement("div");
  div.className="rcard";
  div.innerHTML = `
    <div class="h">${esc(firm.name)}</div>
    <div class="small">${esc(firm.address)}</div>

    <div class="row2">
      <div class="small">Preis f√ºr <b>${esc(productLabel(product))}</b> (‚Ç¨/t)</div>
      <input id="priceInput" type="number" step="0.01" value="${isFinite(currentPrice)?currentPrice:""}" placeholder="Preis ‚Ç¨/t">
      <div class="note">Enter = Preis speichern</div>
    </div>

    <div class="row2" style="margin-top:10px;">
      <div class="small"><b>Notiz</b></div>
      <textarea id="noteTxt" placeholder="Notiz eingeben‚Ä¶">${esc(currentNote)}</textarea>
      <div class="note">Notiz speichert automatisch beim Rausklicken / Schlie√üen.</div>
    </div>
  `;

  const popup = L.popup({closeButton:true, autoClose:true, closeOnClick:true})
    .setLatLng(latlng)
    .setContent(div)
    .openOn(map);

  setTimeout(()=>{
    const inp = div.querySelector("#priceInput");
    const ta  = div.querySelector("#noteTxt");

    // Preis speichern (Enter)
    inp.addEventListener("keydown",(e)=>{
      if(e.key==="Enter"){
        const v = toNum(inp.value);
        if(isFinite(v) && v>0){
          priceOverrides[firm.id] = priceOverrides[firm.id] || {};
          priceOverrides[firm.id][product] = v;
          saveLS(LS_PRICE_OVERRIDES_KEY, priceOverrides);
          renderMarkers();
          calculate();
          // popup bleibt offen (kannst weiter Notiz tippen)
          setTimeout(()=>ta.focus(), 10);
        }
      }
      if(e.key==="Escape"){
        map.closePopup(popup);
      }
    });

    // Notiz Autosave
    const saveNote = ()=>{
      const v = String(ta.value||"").trim();
      if(v) notesStore[firm.id] = v;
      else delete notesStore[firm.id];
      saveLS(LS_NOTES_KEY, notesStore);
      renderMarkers();
    };
    ta.addEventListener("blur", saveNote);
    ta.addEventListener("keydown",(e)=>{
      if(e.key==="Escape") map.closePopup(popup);
    });
    map.on("popupclose", saveNote);

    // Fokus Preis
    inp.focus(); inp.select();
  }, 30);
}
